From c0ad7bb1842c8c7276ae6c542c00e1e61fb1bc2e Mon Sep 17 00:00:00 2001
From: Allan Sandfeld Jensen <allan.jensen@qt.io>
Date: Mon, 14 Oct 2019 12:03:34 +0200
Subject: [PATCH] [Backport] CVE-2019-13691

Security: Fixing URL spoof via cross-site iframe top navigation.

Currently, it is possible to spoof the URL of a site by starting a
navigation in the main frame and having a cross-site iframe initiating
another navigation in its parent frame (with extra steps for it to be
user visible).

This can also be used to cancel any browser initiated navigation in the
main frame.

The CL adresses the issue by adding checks similar to what exists in
BeginNavigation on the FrameProxy::OpenURL path.

Bug: 966914
Change-Id: If547c2ef4b30b2e0323141005583412c12bfef8e
Reviewed-by: Camille Lamy <clamy@chromium.org>
Commit-Queue: Arthur Hemery <ahemery@chromium.org>
Cr-Commit-Position: refs/heads/master@{#668435}
Reviewed-by: Michal Klocek <michal.klocek@qt.io>
---
 .../content/browser/frame_host/navigator.h    |  3 +-
 .../browser/frame_host/navigator_impl.cc      | 51 ++++++++++++++-----
 .../browser/frame_host/navigator_impl.h       |  4 +-
 .../frame_host/render_frame_proxy_host.cc     |  5 +-
 4 files changed, 44 insertions(+), 19 deletions(-)

diff --git a/src/3rdparty/chromium/content/browser/frame_host/navigator.h b/src/3rdparty/chromium/content/browser/frame_host/navigator.h
index fd0b9dd15fb..ef615e4da3f 100644
--- a/src/3rdparty/chromium/content/browser/frame_host/navigator.h
+++ b/src/3rdparty/chromium/content/browser/frame_host/navigator.h
@@ -135,7 +135,8 @@ class CONTENT_EXPORT Navigator : public base::RefCounted<Navigator> {
       const std::string& method,
       scoped_refptr<network::ResourceRequestBody> post_body,
       const std::string& extra_headers,
-      scoped_refptr<network::SharedURLLoaderFactory> blob_url_loader_factory) {}
+      scoped_refptr<network::SharedURLLoaderFactory> blob_url_loader_factory,
+      bool has_user_gesture) {}
 
   // Called after receiving a BeforeUnloadACK IPC from the renderer. If
   // |frame_tree_node| has a NavigationRequest waiting for the renderer
diff --git a/src/3rdparty/chromium/content/browser/frame_host/navigator_impl.cc b/src/3rdparty/chromium/content/browser/frame_host/navigator_impl.cc
index e9a8c947080..603fbff158d 100644
--- a/src/3rdparty/chromium/content/browser/frame_host/navigator_impl.cc
+++ b/src/3rdparty/chromium/content/browser/frame_host/navigator_impl.cc
@@ -51,6 +51,31 @@
 
 namespace content {
 
+namespace {
+
+// A renderer-initiated navigation should be ignored iff a) there is an ongoing
+// request b) which is browser initiated and c) the renderer request is not
+// user-initiated.
+bool ShouldIgnoreIncomingRendererRequest(
+    NavigationRequest* ongoing_navigation_request,
+    bool has_user_gesture) {
+  return ongoing_navigation_request &&
+         ongoing_navigation_request->browser_initiated() && !has_user_gesture;
+}
+
+// Informs the RenderFrameImpl associated with the |frame_tree_node| that a
+// navigation it started was dropped.
+void DropNavigation(FrameTreeNode* frame_tree_node) {
+  if (!IsPerNavigationMojoInterfaceEnabled()) {
+    RenderFrameHost* current_frame_host =
+        frame_tree_node->render_manager()->current_frame_host();
+    current_frame_host->Send(
+        new FrameMsg_DroppedNavigation(current_frame_host->GetRoutingID()));
+  }
+}
+
+}  // namespace
+
 struct NavigatorImpl::NavigationMetricsData {
   NavigationMetricsData(base::TimeTicks start_time,
                         GURL url,
@@ -525,7 +550,8 @@ void NavigatorImpl::NavigateFromFrameProxy(
     const std::string& method,
     scoped_refptr<network::ResourceRequestBody> post_body,
     const std::string& extra_headers,
-    scoped_refptr<network::SharedURLLoaderFactory> blob_url_loader_factory) {
+    scoped_refptr<network::SharedURLLoaderFactory> blob_url_loader_factory,
+    bool has_user_gesture) {
   // |method != "POST"| should imply absence of |post_body|.
   if (method != "POST" && post_body) {
     NOTREACHED();
@@ -566,6 +592,13 @@ void NavigatorImpl::NavigateFromFrameProxy(
     is_renderer_initiated = false;
   }
 
+  if (is_renderer_initiated &&
+      ShouldIgnoreIncomingRendererRequest(
+          render_frame_host->frame_tree_node()->navigation_request(),
+          has_user_gesture)) {
+    return;
+  }
+
   GetContentClient()->browser()->OverrideNavigationParams(
       current_site_instance, &page_transition, &is_renderer_initiated,
       &referrer_to_use);
@@ -648,18 +681,10 @@ void NavigatorImpl::OnBeginNavigation(
     frame_tree_node->ResetNavigationRequest(false, true);
   }
 
-  // The renderer-initiated navigation request is ignored iff a) there is an
-  // ongoing request b) which is browser initiated and c) the renderer request
-  // is not user-initiated.
-  if (ongoing_navigation_request &&
-      ongoing_navigation_request->browser_initiated() &&
-      !common_params.has_user_gesture) {
-    if (!IsPerNavigationMojoInterfaceEnabled()) {
-      RenderFrameHost* current_frame_host =
-          frame_tree_node->render_manager()->current_frame_host();
-      current_frame_host->Send(
-          new FrameMsg_DroppedNavigation(current_frame_host->GetRoutingID()));
-    }
+  // Verify this navigation has precedence.
+  if (ShouldIgnoreIncomingRendererRequest(ongoing_navigation_request,
+                                          common_params.has_user_gesture)) {
+    DropNavigation(frame_tree_node);
     return;
   }
 
diff --git a/src/3rdparty/chromium/content/browser/frame_host/navigator_impl.h b/src/3rdparty/chromium/content/browser/frame_host/navigator_impl.h
index c7e43d3fb5e..03077827dac 100644
--- a/src/3rdparty/chromium/content/browser/frame_host/navigator_impl.h
+++ b/src/3rdparty/chromium/content/browser/frame_host/navigator_impl.h
@@ -86,8 +86,8 @@ class CONTENT_EXPORT NavigatorImpl : public Navigator {
       const std::string& method,
       scoped_refptr<network::ResourceRequestBody> post_body,
       const std::string& extra_headers,
-      scoped_refptr<network::SharedURLLoaderFactory> blob_url_loader_factory)
-      override;
+      scoped_refptr<network::SharedURLLoaderFactory> blob_url_loader_factory,
+      bool has_user_gesture) override;
   void OnBeforeUnloadACK(FrameTreeNode* frame_tree_node,
                          bool proceed,
                          const base::TimeTicks& proceed_time) override;
diff --git a/src/3rdparty/chromium/content/browser/frame_host/render_frame_proxy_host.cc b/src/3rdparty/chromium/content/browser/frame_host/render_frame_proxy_host.cc
index 9f9cb2dd1d3..0c9a84ba870 100644
--- a/src/3rdparty/chromium/content/browser/frame_host/render_frame_proxy_host.cc
+++ b/src/3rdparty/chromium/content/browser/frame_host/render_frame_proxy_host.cc
@@ -343,8 +343,6 @@ void RenderFrameProxyHost::OnOpenURL(
   // in the current tab.
   DCHECK_EQ(WindowOpenDisposition::CURRENT_TAB, params.disposition);
 
-  // TODO(alexmos, creis): Figure out whether |params.user_gesture| needs to be
-  // passed in as well.
   // TODO(lfg, lukasza): Remove |extra_headers| parameter from
   // RequestTransferURL method once both RenderFrameProxyHost and
   // RenderFrameHostImpl call RequestOpenURL from their OnOpenURL handlers.
@@ -356,7 +354,8 @@ void RenderFrameProxyHost::OnOpenURL(
       ui::PAGE_TRANSITION_LINK,
       params.should_replace_current_entry, params.download_policy,
       params.uses_post ? "POST" : "GET", params.resource_request_body,
-      params.extra_headers, std::move(blob_url_loader_factory));
+      params.extra_headers, std::move(blob_url_loader_factory),
+      params.user_gesture);
 }
 
 void RenderFrameProxyHost::OnCheckCompleted() {
-- 
2.24.0

